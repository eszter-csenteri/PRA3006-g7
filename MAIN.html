<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiopharmaceuticals ðŸ§ </title>

    <!-- this links the CSS style file -->
    <link rel="stylesheet" href="/HTML/style.css">

    <!-- D3 library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
<div class="layout">
    <!-- LEFT SIDEBAR -->
    <nav class="sidebar">
        <ul>
            <li><a href="MAIN.html">Home</a></li>
            <li><a href="HTML/about.html">Author</a></li>
            <li><a href="HTML/Dishes.html">Dishes</a></li>
            
        </ul>
    </nav>

    <div class="content-wrapper">
        <h1>
            Radiopharmaceuticals
        </h1>

        <h2 style= "text-align: center;"> Exploring protein targets visually</h2> 

        <h2>What are radiopharmaceuticals?</h2>

        <hr>

        <a href="https://reasonator.toolforge.org/?q=Q33202843&lang=en"
           target="_blank" style="color:white;">
           an inspiration for this research
        </a>

        <br><br>
<!--sidebar ahh-->
        <p>
            <img src="https://pubs.acs.org/cms/10.1021/acscentsci.3c01050/asset/images/large/oc3c01050_0001.jpeg"
                 alt="Radiopharmaceuticals diagram" height="200">
            Radiopharmaceuticals, or medicinal radiocompounds, are a group of pharmaceutical drugs containing radioactive isotopes. Radiopharmaceuticals can be used as diagnostic and therapeutic agents. Radiopharmaceuticals emit radiation themselves, which is different from contrast media which absorb or alter external electromagnetism or ultrasound.
        </p>

        <h3>Summarised desired properties of radiopharmaceuticals:</h3>

        <ul>
            <li>Low binding inhibition constant (Ki)</li>
            <li>Low dissociation constants (Kd &lt; 10 nM)</li>
            <li>Slow but reversible off-rates</li>
            <li>Small molecular weight (&lt; 450 Da)</li>
            <li>Moderately lipophilic (logP 0.9â€“2.5)</li>
            <li>No P-glycoprotein substrate activity</li>
        </ul>

        <hr>
        <div class="box"> Research question: Which receptors are most commonly targeted by radiopharmaceuticals, and how do their binding selectivity profiles vary?</div>

        <h2>How were protein targets determined?</h2>
        <hr>
        <p>When looking for radiopharmaceuticals linkeed to their relevant receptors, only </p> 

        <script>
            console.log("D3 version:", d3.version);

            d3.select(".content-wrapper")
              .append("p")
              
              .style("color", "green");
        </script>

        <div class="section">
            <h2>SPARQL Explorer</h2>

            <label for="endpoint">Endpoint URL:</label><br>
            <input id="endpoint" type="text" value="https://chemblmirror.rdf.bigcat-bioinformatics.org/sparql"><br><br>
<!--query implementation in website here-->
            <label for="query">SPARQL Query:</label><br>
            <textarea id="query" rows="8" style="width:100%;">
PREFIX cco:   <http://rdf.ebi.ac.uk/terms/chembl#>
PREFIX rdfs:  <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd:   <http://www.w3.org/2001/XMLSchema#>

SELECT DISTINCT
  ?molecule           # radiopharmaceutical child
  ?molName
  ?atcCode
  ?molecule2          # parent molecule (the one with binding data)
  ?mol2Name
  ?target
  ?targetName
  ?Ki                 # best Ki (nM) for this target & molecule2
  ?KiBest             # best Ki over all targets for this molecule2
  (xsd:decimal(?Ki) / xsd:decimal(?KiBest) AS ?Selectivity_vs_best)
WHERE {

  ######## Radiopharmaceutical and parent molecule ########

  ?molecule a cco:SmallMolecule ;
            rdfs:label ?molName ;
            cco:atcClassification ?atcCode ;
            cco:hasParentMolecule ?molecule2 .

  # V09 = Diagnostic radiopharmaceuticals
  # V10 = Therapeutic radiopharmaceuticals
  FILTER(STRSTARTS(STR(?atcCode), "V09") || STRSTARTS(STR(?atcCode), "V10"))

  ?molecule2 rdfs:label ?mol2Name .

  ######## Per-target Ki for each parent molecule (molecule2) ########
  # Get the best (minimum) Ki per (molecule2, target)

  {
    SELECT ?molecule2 ?target ?targetName (MIN(xsd:decimal(?value)) AS ?Ki)
    WHERE {
      ?activity  cco:hasMolecule ?molecule2 ;
                 cco:hasAssay    ?assay ;
                 cco:type        ?type ;
                 cco:standardValue ?value .

      ?assay cco:hasTarget ?target .
      ?target rdfs:label ?targetName .

      # Only binding affinity entries
      FILTER(?type = "Ki")
    }
    GROUP BY ?molecule2 ?target ?targetName
  }

  ######## Best Ki per molecule2 (the primary/best-bound target) ########

  {
    SELECT ?molecule2 (MIN(xsd:decimal(?valueBest)) AS ?KiBest)
    WHERE {
      ?activityBest  cco:hasMolecule ?molecule2 ;
                     cco:hasAssay    ?assayBest ;
                     cco:type        ?typeBest ;
                     cco:standardValue ?valueBest .
      FILTER(?typeBest = "Ki")
    }
    GROUP BY ?molecule2
  }
}
ORDER BY ?molecule2 ?Selectivity_vs_best
LIMIT 500

            </textarea><br>

            <button id="run" style="background-color:#04AA6D; color:white; padding:5px 10px; border:none; cursor:pointer;">
                Run Query
            </button>

            <!--test for the dropdown-->            
            <label style = "color:white;">View alo</label>
            <select id = "viewSelector" style = "margin-left:10px; padding :5px;">
                
- eulav noitpo>
            
            
            <div id="results" style="margin-top:20px; color:white;"></div>

            <h2>Knowledge graph</h2>
            <svg id="graph" width="1000" height="1000" style="background:#102030;"></svg>
        </div>
    </div>
</div>

<script>



// ---- Render JSON result as an HTML table ----
// ---- Render JSON result as an HTML table ----
function renderResults(data) {

  // "bindings" contains all result rows from the SPARQL endpoint.
  // Example: data.results.bindings = [{ var1:{value:".."}, var2:{value:".."} }, ...]
  const bindings = data.results?.bindings || [];

  // If no results, return simple message.
  if (bindings.length === 0) {
    return '<p>No results.</p>';
  }

  // "vars" contains the variable names returned by SPARQL (column headers)
  const vars = data.head?.vars || Object.keys(bindings[0] || {});

  // Start building the HTML table
  let html = '<table style="border-collapse:collapse; color:white; font-size:0.9rem;">';

  // ---- Header row ----
  html += '<thead><tr>';
  vars.forEach(v => {
    html += `<th style="border:1px solid #555; padding:4px;">${escapeHtml(v)}</th>`;
  });
  html += '</tr></thead><tbody>';

  // ---- Table rows ----
  bindings.forEach(row => {
    html += '<tr>';

    // Loop through each variable and print the corresponding cell value
    vars.forEach(v => {
      const cell  = row[v];                    // e.g. { type:"literal", value:"example" }
      const value = cell ? cell.value : '';    // If no cell value -> empty string

      let cellHtml = escapeHtml(value);

      // If itâ€™s a URI, make it clickable
      if (cell && cell.type === 'uri' && value) {
        const safeUri = escapeHtml(value);
        cellHtml = `<a href="${safeUri}" target="_blank" style="color:#7fc5ff;">${safeUri}</a>`;
      }

      html += `<td style="border:1px solid #555; padding:4px;">${cellHtml}</td>`;
    });

    html += '</tr>';
  });

  html += '</tbody></table>';
  return html;  // Return the full HTML table as a string
}

// section above comments done


  // ---- Main runner (GET â€“ works for most public endpoints) ----


// ---- Render JSON result as an HTML table ----
function renderResults(data) {
  // All result rows from the SPARQL endpoint
  const bindings = data.results?.bindings || [];

  if (bindings.length === 0) {
    return '<p>No results.</p>';
  }

  // Variable names (columns)
  const vars = data.head?.vars || Object.keys(bindings[0] || {});

  let html = '<table style="border-collapse:collapse; color:white; font-size:0.9rem;">';

  // Header
  html += '<thead><tr>';
  vars.forEach(v => {
    html += `<th style="border:1px solid #555; padding:4px;">${escapeHtml(v)}</th>`;
  });
  html += '</tr></thead><tbody>';

  // Rows
  bindings.forEach(row => {
    html += '<tr>';

    vars.forEach(v => {
      const cell  = row[v];
      const value = cell ? cell.value : '';

      let cellHtml = escapeHtml(value);

      // Make URIs clickable
      if (cell && cell.type === 'uri' && value) {
        const safeUri = escapeHtml(value);
        cellHtml = `<a href="${safeUri}" target="_blank" style="color:#7fc5ff;">${safeUri}</a>`;
      }

      html += `<td style="border:1px solid #555; padding:4px;">${cellHtml}</td>`;
    });

    html += '</tr>';
  });

  html += '</tbody></table>';
  return html;
}

// ---- Safely escape HTML content ----
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text == null ? '' : String(text);
  return div.innerHTML;
}

// ---- Main runner (GET â€“ works for most public endpoints) ----
async function runSparql() {
  const endpoint = document.getElementById('endpoint').value.trim();
  const query    = document.getElementById('query').value.trim();
  const resultsDiv = document.getElementById('results');

  if (!endpoint || !query) {
    resultsDiv.innerHTML = '<p style="color:red;">Endpoint and query required.</p>';
    return;
  }

  // Show loading
  resultsDiv.innerHTML = '<p>Loadingâ€¦</p>';

  let url;
  try {
    url = new URL(endpoint);
  } catch (e) {
    resultsDiv.innerHTML = `<p style="color:red;">Invalid endpoint URL.</p>`;
    console.error('Invalid endpoint URL:', endpoint, e);
    return;
  }

  url.searchParams.append('query', query);
  url.searchParams.append('format', 'json');

  try {
    console.log('Sending SPARQL request to:', url.toString());

    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: {
        'Accept': 'application/sparql-results+json'
      }
    });

    console.log('Response status:', response.status);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    console.log('SPARQL JSON result:', data);

    // Render table
    resultsDiv.innerHTML = renderResults(data);

    // Draw graph (make sure this function exists)
    if (typeof drawGraphFromSparql === 'function') {
      drawGraphFromSparql(data);
    } else {
      console.warn('drawGraphFromSparql is not defined.');
    }

  } catch (err) {
    console.error('SPARQL error:', err);
    resultsDiv.innerHTML =
      `<p style="color:red;">Error: ${escapeHtml(err.message)}</p>`;
  }
}

// ---- Wire the button to runSparql ----
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('run');
  if (btn) {
    btn.addEventListener('click', runSparql);
  }
});




  // ---- Build nodes + links from SPARQL result ----


  
  // ---- Build nodes + links for: molName â€“ mol2Name â€“ targetName ----
function buildGraphFromSparql(data) {
  const bindings = data.results?.bindings || [];

  const nodeMap = new Map(); // avoid duplicate nodes
  const links = [];

  // Helper to add/get a node
  function addNode(id, label, type) {
    if (!id) return null; // skip if no URI
    if (!nodeMap.has(id)) {
      nodeMap.set(id, { id, label, type });
    }
    return nodeMap.get(id);
  }

  bindings.forEach(row => {
    const moleculeURI = row.molecule?.value;   // radiopharmaceutical
    const molName     = row.molName?.value || moleculeURI;

    const parentURI   = row.molecule2?.value;  // parent molecule
    const mol2Name    = row.mol2Name?.value || parentURI;

    const targetURI   = row.target?.value;     // biological target
    const targetName  = row.targetName?.value || targetURI;

    // Create nodes
    const moleculeNode = addNode(moleculeURI, molName, "molecule");
    const parentNode   = addNode(parentURI,  mol2Name, "parent");
    const targetNode   = addNode(targetURI,  targetName, "target");

    // Links: molecule -> parent
    if (moleculeNode && parentNode) {
      links.push({
        source: moleculeNode.id,
        target: parentNode.id,
        relation: "hasParentMolecule"
      });
    }

    // Links: parent -> target
    if (parentNode && targetNode) {
      links.push({
        source: parentNode.id,
        target: targetNode.id,
        relation: "hasTarget"
      });
    }
  });

  return {
    nodes: Array.from(nodeMap.values()),
    links
  };
}

// ---- Draw force-directed knowledge graph ----
function drawGraphFromSparql(data) {
  const graph = buildGraphFromSparql(data);

  const svg = d3.select("#graph");
  svg.selectAll("*").remove(); // clear previous graph

  const width  = +svg.attr("width");
  const height = +svg.attr("height");

  const color = d3.scaleOrdinal()

    .domain(["molecule", "parent", "target"])
    .range(["#ffcc00", "#66ccff", "#ff6699"]);
//legendary ah :
// ---- Legend ----
const legendData = [
  { type: "molecule", label: "Molecule (molName)" },
  { type: "parent",   label: "Parent Molecule (mol2Name)" },
  { type: "target",   label: "Target (targetName)" }
];

  const legend = svg.append("g")
    .attr("class", "legend")
    .attr("transform", "translate(20, 20)");

  legend.selectAll("legend-dots")
    .data(legendData)
    .enter()
    .append("circle")
    .attr("cx", 0)
    .attr("cy", (d, i) => i * 22)
    .attr("r", 7)
    .style("fill", d => color(d.type));

  legend.selectAll("legend-labels")
    .data(legendData)
    .enter()
    .append("text")
    .attr("x", 15)
    .attr("y", (d, i) => i * 22 + 4)
    .style("fill", "white")
    .style("font-size", "14px")
    .text(d => d.label);
  //other

  const simulation = d3.forceSimulation(graph.nodes)
    .force("link", d3.forceLink(graph.links)
      .id(d => d.id)
      .distance(80))
    .force("charge", d3.forceManyBody().strength(-120))
    .force("center", d3.forceCenter(width / 2, height / 2))
    // keep things roughly in the middle
    .force("x", d3.forceX(width / 2).strength(0.05))
    .force("y", d3.forceY(height / 2).strength(0.05));

  // Links (edges)
  const link = svg.append("g")
    .attr("stroke", "#aaa")
    .attr("stroke-width", 1)
    .selectAll("line")
    .data(graph.links)
    .enter()
    .append("line");

  // Nodes (circles + labels)
  const node = svg.append("g")
    .selectAll("g")
    .data(graph.nodes)
    .enter()
    .append("g")
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  node.append("circle")
    .attr("r", 8)
    .attr("fill", d => color(d.type));

  node.append("title")
    .text(d => d.label);

  node.append("text")
    .attr("x", 10)
    .attr("y", 3)
    .attr("fill", "#ffffff")
    .attr("font-size", "10px")
    .text(d => d.label);

  simulation.on("tick", () => {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("transform", d => `translate(${d.x},${d.y})`);
  });

  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
}

//add bar graph for binding activities



  document.getElementById('run').addEventListener('click', runSparql);
</script>

<div class="grid-container">
  <div class="item">title </div>
  <div class="item">sidebar </div>
  <div class="item">content </div>
  <div class="item">footer </div>

</body>
</html>
