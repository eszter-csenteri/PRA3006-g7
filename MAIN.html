<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiopharmaceuticals ðŸ§ </title>

    <!-- this links the CSS style file -->
    <link rel="stylesheet" href="/HTML/style.css">

    <!-- D3 library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
<div class="layout">
    <!-- LEFT SIDEBAR -->
    <nav class="sidebar">
        <ul>
            <li><a href="MAIN.html">Home</a></li>
            <li><a href="HTML/about.html">Author</a></li>
            <li><a href="HTML/Dishes.html">Dishes</a></li>
            
        </ul>
    </nav>

    <div class="content-wrapper">
        <h1>
            Radiopharmaceutical Use Visualiser
        </h1>

        <h2>What are radiopharmaceuticals?</h2>

        <hr>

        <a href="https://reasonator.toolforge.org/?q=Q33202843&lang=en"
           target="_blank" style="color:white;">
           an inspiration for this research
        </a>

        <br><br>
<!--sidebar ah-->
        <p style="color: white;">
            <img src="https://pubs.acs.org/cms/10.1021/acscentsci.3c01050/asset/images/large/oc3c01050_0001.jpeg"
                 alt="Radiopharmaceuticals diagram" height="200">
            Radiopharmaceuticals, or medicinal radiocompounds, are a group of pharmaceutical drugs containing radioactive isotopes. Radiopharmaceuticals can be used as diagnostic and therapeutic agents. Radiopharmaceuticals emit radiation themselves, which is different from contrast media which absorb or alter external electromagnetism or ultrasound.
        </p>

        <strong style="color:white;">Summarised desired properties of radiopharmaceuticals:</strong>

        <ul style="color:white;">
            <li>Low binding inhibition constant (Ki)</li>
            <li>Low dissociation constants (Kd &lt; 10 nM)</li>
            <li>Slow but reversible off-rates</li>
            <li>Small molecular weight (&lt; 450 Da)</li>
            <li>Moderately lipophilic (logP 0.9â€“2.5)</li>
            <li>No P-glycoprotein substrate activity</li>
        </ul>

        <hr>
        <div class="box" style="color:white;"> Research question: Which targets do radiopharmaceuticals bind to?</div>

        

        <script>
            console.log("D3 version:", d3.version);

            d3.select(".content-wrapper")
              .append("p")
              
              .style("color", "green");
        </script>

        <div class="section" style="color:rgb(42, 217, 68); padding-top: 50px; padding-right: 20px;">
            <h2>SPARQL Explorer</h2>

            <label for="endpoint">Endpoint URL:</label><br>
            <input id="endpoint" type="text" value="https://bio2rdf.org/sparql"><br><br>
<!--query implementation in website here-->
            <label for="query">SPARQL Query:</label><br>
            <textarea id="query" rows="8" style="width:100%;">
PREFIX rdfs:    &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX dct:     &lt;http://purl.org/dc/terms/&gt;
PREFIX pharmgkb:&lt;http://bio2rdf.org/pharmgkb_vocabulary:&gt;

SELECT DISTINCT
  ?drug
  ?drugLabel
  ?atc
  ?atcID
WHERE {
  ?drug pharmgkb:x-atc ?atc .
  ?drug rdfs:label ?drugLabel .
  ?atc  dct:identifier ?atcID .

  FILTER (
    STRSTARTS(STR(?atc), "http://bio2rdf.org/atc:V09") ||
    STRSTARTS(STR(?atc), "http://bio2rdf.org/atc:V10")
  )
}

            </textarea><br>

            <button id="run" style="background-color:#04AA6D; color:white; padding:5px 10px; border:none; cursor:pointer;">
                Run Query
            </button>

            <div id="results" style="margin-top:20px; color:white;"></div>

            <h2>Knowledge graph</h2>
            <svg id="graph" width="1000" height="1000" style="background:#102030;"></svg>
        </div>
    </div>
</div>

<script>



// ---- Render JSON result as an HTML table ----
function renderResults(data) {

  // "bindings" contains all result rows from the SPARQL endpoint.
  // Example structure: data.results.bindings = [{ var1:{value:".."}, var2:{value:".."} }, ...]
  const bindings = data.results?.bindings;

  // If no results, return simple message.
  if (!bindings || bindings.length === 0) return '<p>No results.</p>'; //in case there are no bindings

  // "vars" contains the variable names returned by SPARQL (column headers)
  const vars = data.head.vars; //column headers

  // Start building the HTML table
  let html = '<table style="border-collapse:collapse; color:white;">';

  // ---- Header row ----
  html += '<thead><tr>';
  vars.forEach(v => {
    html += `<th style="border:1px solid #555; padding:4px;">${v}</th>`;
  });
  html += '</tr></thead><tbody>';

  // ---- Table rows ----
  bindings.forEach(row => {
    html += '<tr>';

    // Loop through each variable and print the corresponding cell value
    vars.forEach(v => {
      const cell = row[v];             // cell is an object like { type:"literal", value:"example" }
      const value = cell ? cell.value : ''; // If no cell value -> empty string

      // Escape HTML to prevent DOM injection (important for safety)
      html += `<td style="border:1px solid #555; padding:4px;">${escapeHtml(value)}</td>`;
    });

    html += '</tr>';
  });

  html += '</tbody></table>';
  return html;  // Return the full HTML table as a string
}

// ---- Safely escape HTML content ----
// Prevents strings like "<script>" from being interpreted as HTML.
// It does this by placing the text inside a temporary <div>, then reading its textContent.
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML; // the browser automatically escapes any HTML characters
}

// section above comments done


  // ---- Main runner (GET â€“ works for most public endpoints) ----



// Main function to run the SPARQL query when user clicks a button, for example
async function runSparql() {
  // Get the SPARQL endpoint URL from the input field
  const endpoint = document.getElementById('endpoint').value.trim();

  // Get the SPARQL query string from the text area/input
  const query = document.getElementById('query').value.trim();

  // The div where we will show messages (loading, errors) and the result table
  const resultsDiv = document.getElementById('results');

  // Basic validation: make sure both endpoint and query are provided
  if (!endpoint || !query) {
    resultsDiv.innerHTML = '<p style="color:red;">Endpoint and query required.</p>';
    return; // stop running if missing
  }

  // Show a loading message while we wait for the SPARQL endpoint
  resultsDiv.innerHTML = '<p>Loadingâ€¦</p>';

  // Build the request URL with query parameters
  const url = new URL(endpoint);
  url.searchParams.append('query', query);   // SPARQL query
  url.searchParams.append('format', 'json'); // ask for JSON results

  try {
    // Send the HTTP GET request to the SPARQL endpoint
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        // Explicitly request SPARQL results in JSON format
        'Accept': 'application/sparql-results+json'
      }
    });

    // If the HTTP status is not in the 200â€“299 range, treat it as an error
    if (!response.ok) throw new Error(`HTTP ${response.status}`);

    // Parse the response body as JSON (this should match the SPARQL JSON format)
    const data = await response.json();

    // Render the result table using your renderResults() function
    resultsDiv.innerHTML = renderResults(data);

    // Additionally, draw a graph based on the same SPARQL result
    // (Assumes drawGraphFromSparql is defined elsewhere)
    drawGraphFromSparql(data);

  } catch (err) {
    // If anything goes wrong (network error, bad JSON, HTTP error, etc.),
    // show a red error message. escapeHtml prevents HTML injection.
    resultsDiv.innerHTML =
      `<p style="color:red;">Error: ${escapeHtml(err.message)}</p>`;
  }
}




  // ---- Build nodes + links from SPARQL result ----


  
  function buildGraphFromSparql(data) { //
    
  // Get the list of result rows from the SPARQL result.
  // If results or bindings don't exist, fallback to an empty array.
    const bindings = data.results?.bindings || [];

  // nodeMap ensures we do NOT create duplicate nodes for the same URI
    const nodeMap = new Map();
    
    const links = [];   // Array for storing all graph links (edges)

  /**
   * Helper function to create a node if it doesn't exist
   * id     = the unique identifier (usually URI)
   * label  = a human-readable label
   * type   = category ("drug", "atc", etc.)
   */
    function addNode(id, label, type) {
      if (!nodeMap.has(id)) {   // Only create the node if this ID is not already in the map
        nodeMap.set(id, { id, label, type });
      }
      return nodeMap.get(id);  // Return the existing or newly created node
    }
//process sparql results
    bindings.forEach(row => { //loop through each row to extract the drug
      const drugURI   = row.drug?.value;
      const drugLabel = row.drugLabel?.value || drugURI;
      const atcURI    = row.atc?.value;
      const atcID     = row.atcID?.value || atcURI;

//since sparql querry are catagorised in a way such that {
 // "drug":      { "type": "uri", "value": "http://example/drug/123" },
  //"drugLabel": { "type": "literal", "value": "Aspirin" },
  //"atc":       { "type": "uri", "value": "http://example/atc/A01" },
  //"atcID":     { "type": "literal", "value": "A01" }
//     }



      if (!drugURI || !atcURI) return;

      const drugNode = addNode(drugURI, drugLabel, "drug");
      const atcNode  = addNode(atcURI,  atcID,     "atc");

      links.push({
        source: drugNode.id,
        target: atcNode.id
      });
    });

//alo


    return {
      nodes: Array.from(nodeMap.values()),
      links: links
    };
  }

  // ---- Draw force-directed graph with D3 ----
  function drawGraphFromSparql(data) {
    const graph = buildGraphFromSparql(data);

    const svg = d3.select("#graph");
    svg.selectAll("*").remove(); // clear old graph

    const width = +svg.attr("width");
    const height = +svg.attr("height");

    const color = d3.scaleOrdinal()
      .domain(["drug", "atc"])
      .range(["#ffcc00", "#66ccff"]);

    const simulation = d3.forceSimulation(graph.nodes)
      .force("link", d3.forceLink(graph.links)
        .id(d => d.id)
        .distance(10))
      .force("charge", d3.forceManyBody().strength(-40))
      .force("center", d3.forceCenter(width / 2, height / 2))
  // NEW: gently pull every node towards the middle
  .force("x", d3.forceX(width / 2).strength(0.05))
  .force("y", d3.forceY(height / 2).strength(0.05));

    const link = svg.append("g")
      .attr("stroke", "#aaa")
      .attr("stroke-width", 1.2)
      .selectAll("line")
      .data(graph.links)
      .enter().append("line");

    const node = svg.append("g")
      .selectAll("circle")
      .data(graph.nodes)
      .enter().append("circle")
        .attr("r", 8)
        .attr("fill", d => color(d.type))
        .call(
          d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended)
        );

    const label = svg.append("g")
      .selectAll("text")
      .data(graph.nodes)
      .enter().append("text")
        .attr("font-size", 10)
        .attr("fill", "white")
        .attr("dx", 10)
        .attr("dy", 4)
        .text(d => d.label);

    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      label
        .attr("x", d => d.x)
        .attr("y", d => d.y);
    });

    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
  }

  document.getElementById('run').addEventListener('click', runSparql);
</script>

</body>
</html>
