<!DOCTYPE html>
<html lang="en">

<head>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;600&family=Inter:wght@300;400&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="Other/RadioactiveSign.png">
  <title>Radiopharmaceuticals </title>

  <!-- CSS -->
  <link rel="stylesheet" href="HTML/style.css">
  <style>
    /* Hide the entire SPARQL editor UI – keeps functionality but removes it visually */
    #sparqlEditor { display: none !important; }
  </style>
  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
  <div class="layout">
    
    
    
    
    <!-- LEFT SIDEBAR -->
    <nav class="sidebar">
      <ul>
        <li><a href="HTML/introPage.html">Home</a></li>
        <li><a href="HTML/about.html">Author</a></li>
        <li><a href="HTML/Dishes.html">Dishes</a></li>
        <li><a href="HTML/sparql.html">Sparkling Wine Explorer™</a></li>
      </ul>
    </nav>

    <div class="content-wrapper">
      <h1>RADIOPHARMACEUTICALS</h1>
      <h2 style="text-align:center;">Exploring protein targets visually</h2>

      <h2>What are radiopharmaceuticals?</h2>
      <hr>
      <i> You can find an inspiration for our project
        <a href="https://reasonator.toolforge.org/?q=Q33202843&lang=en" target="_blank" style="color:white;">
          here.
        </a>

      </i>
      <br><br>

      <p>
        <img src="https://pubs.acs.org/cms/10.1021/acscentsci.3c01050/asset/images/large/oc3c01050_0001.jpeg"
          alt="Radiopharmaceuticals diagram" height="200">
          <img src="Other/pet2.gif" height="200">
          
        Radiopharmaceuticals, or medicinal radiocompounds, are a group of pharmaceutical drugs containing radioactive
        isotopes...
        
        <br><br><br><br>
      </p>

      <hr>
      <div class="box">
        <h3>Research question:</h3>
        <p> Which receptors are most commonly targeted by radiopharmaceuticals, and how do their binding
        selectivity profiles vary?</p>
        
      </div>

      <h2>Method</h2>
      <hr>
      <div class="box">
        <h3>How were radiopharmaceuticals identified? </h3>
        <p> Radiopharmaceuticals were found from the ChEMBL endpoint using their <strong>Anatomical Therapeutic Chemical (ATC) </strong> classification codes. Compounds with ATC codes beginning with <strong>V09</strong> (Diagnostic radiopharmaceuticals) or <strong>V10</strong> (Therapeutic radiopharmaceuticals) were selected for this project. </p>
        </div>
        <p>When looking for radiopharmaceuticals linked to their relevant receptors, only three molecules had data. The absence of data is likely due to the difficulty of obtaining this biological information, as assays for radioactive molecules are expensive and complex. However, attaching a radioactive atom usually does not change the binding pharmacology or affinity of the compound to its receptor. Thus, the radiopharmaceutical's binding affinity and selectivity to receptors can be equivalent to its <strong>"parent"</strong> molecule, or the non-radioactive version. Thus, all downstream analyses were based on the parent molecule’s binding data. </p>
        
        <h3>How were primary targets for parent molecules determined? </h3>
<p>
  <em>K<sub>i</sub></em> is the inhibition constant, which defines how tightly a molecule binds to a protein. 
  A low <em>K<sub>i</sub></em> means strong binding, while a high <em>K<sub>i</sub></em> indicates weak binding. 
  <em>K<sub>i</sub></em> values are commonly used in drug discovery to quantify ligand–protein interactions 
  and discover which proteins the parent molecule prefers.
</p>

<p>
  Primary targets were defined as the proteins with the lowest <em>K<sub>i</sub></em> (best binding).<br>
  Secondary, or off-targets, were defined as proteins with higher <em>K<sub>i</sub></em>.
</p>

<h3>How was target selectivity quantified?</h3>

<p>
  Selectivity quantifies how much better a molecule binds to its primary target compared to its other targets. 
  The selectivity ratio was determined by dividing the <em>K<sub>i</sub></em> of the target by the minimum 
  <em>K<sub>i</sub></em> value:
</p>

<p>
  <strong>Selectivity ratio</strong> = <em>K<sub>i,target</sub></em> / <em>K<sub>i,min</sub></em>
</p>
<div style="color: white;">
<table border="1" cellspacing="0" cellpadding="6">
  <thead>
    <tr>
      <th>Selectivity ratio</th>
      <th>Interpretation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.0</td>
      <td>Primary target, strongest binder</td>
    </tr>
    <tr>
      <td>&gt; 1</td>
      <td>Off-target, weaker binding</td>
    </tr>
    <tr>
      <td>Large ratio</td>
      <td>Highly selective binding; large preference for main target</td>
    </tr>
    <tr>
      <td>Small ratio</td>
      <td>Weak selectivity; the molecule binds to proteins almost equally well</td>
    </tr>
  </tbody>
</table>

      </div>
  <h2>Results</h2>
<p>
  The knowledge graph was used to visualize relationships between radiopharmaceuticals (yellow nodes), 
  their parent molecules (blue nodes), and the protein targets (pink nodes) they bind to. 
  The edges represent binding relationships where each parent molecule is connected to its protein targets, 
  and each radiopharmaceutical is linked to its non-radioactive parent molecule.
</p>

<p>Some protein targets appear multiple times, connected to different parent molecules:</p>
<ul>
  <li>Carbonic anhydrase isoforms (I, II, IV, IX) linked to sodium iodide and sodium fluoride</li>
  <li>Carbonic anhydrase II links sodium iodide and sodium phosphate</li>
  <li>Beta amyloid A4 protein targeted by flutemetamol and florbetapir</li>
</ul>

<p>Others are specific to a type of protein:</p>
<ul>
  <li>Monoamine transporters (dopamine, serotonin, norepinephrine) linked to iodine 2β-carbomethoxy-3β-(4-iodophenyl)-tropane</li>
  <li>Dopamine receptors (D1, D2, D3, D4) only targeted by iolopride</li>
</ul>

<p>
  Thus, the knowledge graph shows that radiopharmaceuticals target a limited category of proteins, 
  illustrating their selectivity for specific biological functions.
</p>

      
      <hr style="height:5px; background-color: white;">
      
      <script>
        console.log("D3 version:", d3.version);
      </script>

      <div class="section">


        <label for="endpoint">Endpoint URL:</label><br>
        <input id="endpoint" type="text" value="https://chemblmirror.rdf.bigcat-bioinformatics.org/sparql"><br><br>

        <!-- SPARQL QUERY -->
        <label for="query">SPARQL Query:</label><br>
        <textarea id="query" rows="8" style="width:100%;">
PREFIX cco:   <http://rdf.ebi.ac.uk/terms/chembl#>
PREFIX rdfs:  <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd:   <http://www.w3.org/2001/XMLSchema#>

SELECT DISTINCT
  ?molecule           # radiopharmaceutical child
  ?molName
  ?atcCode
  ?molecule2          # parent molecule (the one with binding data)
  ?mol2Name
  ?target
  ?targetName
  ?Ki                 # best Ki (nM) for this target & molecule2
  ?KiBest             # best Ki over all targets for this molecule2
  (xsd:decimal(?Ki) / xsd:decimal(?KiBest) AS ?Selectivity_vs_best)
WHERE {

  ######## Radiopharmaceutical and parent molecule ########

  ?molecule a cco:SmallMolecule ;
            rdfs:label ?molName ;
            cco:atcClassification ?atcCode ;
            cco:hasParentMolecule ?molecule2 .

  FILTER(STRSTARTS(STR(?atcCode), "V09") || STRSTARTS(STR(?atcCode), "V10"))

  ?molecule2 rdfs:label ?mol2Name .

  ######## Per-target Ki for each parent molecule (molecule2) ########

  {
    SELECT ?molecule2 ?target ?targetName (MIN(xsd:decimal(?value)) AS ?Ki)
    WHERE {
      ?activity  cco:hasMolecule ?molecule2 ;
                 cco:hasAssay    ?assay ;
                 cco:type        ?type ;
                 cco:standardValue ?value .

      ?assay cco:hasTarget ?target .
      ?target rdfs:label ?targetName .

      FILTER(?type = "Ki")
    }
    GROUP BY ?molecule2 ?target ?targetName
  }

  ######## Best Ki per molecule2 ########

  {
    SELECT ?molecule2 (MIN(xsd:decimal(?valueBest)) AS ?KiBest)
    WHERE {
      ?activityBest  cco:hasMolecule ?molecule2 ;
                     cco:hasAssay    ?assayBest ;
                     cco:type        ?typeBest ;
                     cco:standardValue ?valueBest .
      FILTER(?typeBest = "Ki")
    }
    GROUP BY ?molecule2
  }
}
ORDER BY ?molecule2 ?Selectivity_vs_best
LIMIT 500
      </textarea><br>

        <button id="run" style="background-color:#04AA6D; color:white; padding:5px 10px; border:none; cursor:pointer;">
          Run Query 
        </button>

        <!-- VIEW SELECTOR -->
        <br><br>
        <label style="color:white;">View:</label>
        <select id="viewSelector" style="margin-left:10px; padding:5px;">
          <option value="table">Table (Query Results)</option>
          <option value="graph">Knowledge Graph</option>
          <option value="chart">Selectivity Chart</option>
        </select>

        <!-- TABLE RESULTS -->
        <div id="tableContainer" style="margin-top:20px; color:white;">
          <div id="results"></div>
        </div>
    
        <!-- GRAPH RESULTS -->
        <div id="graphContainer" style="display:none; margin-top:20px;">
          <h2 style="color:white;">Knowledge graph</h2>
          <svg id="graph" width="850" height="800" style="background:#102030;"></svg>
        </div>

        <!-- CHART RESULTS -->
        <div id="chartContainer" style="display:none; margin-top:20px;">
          <h2 style="color:white;">Selectivity vs best Ki</h2>
          <label style="color:white;">Parent molecule:</label>
          <select id="moleculeSelector" style="margin-left:10px; padding:5px;"></select>

          <span style="margin-left: 20px; color: white;">Scale:</span>
          <button id="btnLinear"
            style="margin-left:5px; padding:5px; cursor:pointer; background-color:#66ccff; border:none;">Linear</button>
          <button id="btnLog"
            style="margin-left:5px; padding:5px; cursor:pointer; background-color:#ddd; border:none;">Logarithmic</button>

          <svg id="chart" width="1000" height="400" style="background:#102030; margin-top:10px;"></svg>
        </div>


        <script>
          let lastSparqlData = null;  // will store the latest SPARQL JSON
          let currentScaleType = "linear"; // "linear" or "log"

          // ---------- TABLE RENDERING ----------
          function renderResults(data) {
            const bindings = data.results?.bindings || [];

            if (bindings.length === 0) {
              return '<p>No results.</p>';
            }

            const vars = data.head?.vars || Object.keys(bindings[0] || {});
            let html = '<table style="border-collapse:collapse; color:white; font-size:0.9rem;">';

            // Header
            html += '<thead><tr>';
            vars.forEach(v => {
              html += `<th style="border:1px solid #555; padding:4px;">${escapeHtml(v)}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Rows
            bindings.forEach(row => {
              html += '<tr>';
              vars.forEach(v => {
                const cell = row[v];
                const value = cell ? cell.value : '';
                let cellHtml = escapeHtml(value);

                if (cell && cell.type === 'uri' && value) {
                  const safeUri = escapeHtml(value);
                  cellHtml = `<a href="${safeUri}" target="_blank" style="color:#7fc5ff;">${safeUri}</a>`;
                }

                html += `<td style="border:1px solid #555; padding:4px;">${cellHtml}</td>`;
              });
              html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
          }

          function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text == null ? '' : String(text);
            return div.innerHTML;
          }

          // ---------- SPARQL RUNNER ----------
          async function runSparql() {
            const endpoint = document.getElementById('endpoint').value.trim();
            const query = document.getElementById('query').value.trim();
            const resultsDiv = document.getElementById('results');

            if (!endpoint || !query) {
              resultsDiv.innerHTML = '<p style="color:red;">Endpoint and query required.</p>';
              return;
            }

            resultsDiv.innerHTML = '<p>Loading…</p>';

            let url;
            try {
              url = new URL(endpoint);
            } catch (e) {
              resultsDiv.innerHTML = `<p style="color:red;">Invalid endpoint URL.</p>`;
              console.error('Invalid endpoint URL:', endpoint, e);
              return;
            }

            url.searchParams.append('query', query);
            url.searchParams.append('format', 'json');

            try {
              console.log('Sending SPARQL request to:', url.toString());

              const response = await fetch(url.toString(), {
                method: 'GET',
                headers: { 'Accept': 'application/sparql-results+json' }
              });

              console.log('Response status:', response.status);

              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }

              const data = await response.json();
              console.log('SPARQL JSON result:', data);

              // ✅ STORE SPARQL DATA globally for chart & interactions
              lastSparqlData = data;

              // ✅ Render table
              resultsDiv.innerHTML = renderResults(data);

              // ✅ Draw graph
              if (typeof drawGraphFromSparql === 'function') {
                drawGraphFromSparql(data);
              } else {
                console.warn('drawGraphFromSparql is not defined.');
              }

              // ✅ Initialize selectivity chart molecule dropdown
              initChartDataFromSparql(data);

              // ✅ Reset view to TABLE by default
              document.getElementById("viewSelector").value = "table";
              document.getElementById("tableContainer").style.display = "block";
              document.getElementById("graphContainer").style.display = "none";
              document.getElementById("chartContainer").style.display = "none";

            } catch (err) {
              console.error('SPARQL error:', err);
              resultsDiv.innerHTML =
                `<p style="color:red;">Error: ${escapeHtml(err.message)}</p>`;
            }
          }

          // ---------- GRAPH BUILDING ----------
          function buildGraphFromSparql(data) {
            const bindings = data.results?.bindings || [];

            const nodeMap = new Map();
            const links = [];

            function addNode(id, label, type) {
              if (!id) return null;
              if (!nodeMap.has(id)) {
                nodeMap.set(id, { id, label, type });
              }
              return nodeMap.get(id);
            }

            bindings.forEach(row => {
              const moleculeURI = row.molecule?.value;
              const molName = row.molName?.value || moleculeURI;

              const parentURI = row.molecule2?.value;
              const mol2Name = row.mol2Name?.value || parentURI;

              const targetURI = row.target?.value;
              const targetName = row.targetName?.value || targetURI;

              const moleculeNode = addNode(moleculeURI, molName, "molecule");
              const parentNode = addNode(parentURI, mol2Name, "parent");
              const targetNode = addNode(targetURI, targetName, "target");

              if (moleculeNode && parentNode) {
                links.push({
                  source: moleculeNode.id,
                  target: parentNode.id,
                  relation: "hasParentMolecule"
                });
              }

              if (parentNode && targetNode) {
                links.push({
                  source: parentNode.id,
                  target: targetNode.id,
                  relation: "hasTarget"
                });
              }
            });

            return {
              nodes: Array.from(nodeMap.values()),
              links
            };
          }

          // ---------- GRAPH DRAWING ----------
          function drawGraphFromSparql(data) {
            const graph = buildGraphFromSparql(data);

            const svg = d3.select("#graph");
            svg.selectAll("*").remove();

            const width = +svg.attr("width");
            const height = +svg.attr("height");

            const color = d3.scaleOrdinal()
              .domain(["molecule", "parent", "target"])
              .range(["#ffcc00", "#66ccff", "#ff6699"]);

            // Legend
            const legendData = [
              { type: "molecule", label: "Molecule (molName)" },
              { type: "parent", label: "Parent Molecule (mol2Name)" },
              { type: "target", label: "Target (targetName)" }
            ];

            const legend = svg.append("g")
              .attr("class", "legend")
              .attr("transform", "translate(20, 20)");

            legend.selectAll("legend-dots")
              .data(legendData)
              .enter()
              .append("circle")
              .attr("cx", 0)
              .attr("cy", (d, i) => i * 22)
              .attr("r", 7)
              .style("fill", d => color(d.type));

            legend.selectAll("legend-labels")
              .data(legendData)
              .enter()
              .append("text")
              .attr("x", 15)
              .attr("y", (d, i) => i * 22 + 4)
              .style("fill", "white")
              .style("font-size", "14px")
              .text(d => d.label);

            const simulation = d3.forceSimulation(graph.nodes)
              .force("link", d3.forceLink(graph.links)
                .id(d => d.id)
                .distance(80))
              .force("charge", d3.forceManyBody().strength(-120))
              .force("center", d3.forceCenter(width / 2, height / 2))
              .force("x", d3.forceX(width / 2).strength(0.05))
              .force("y", d3.forceY(height / 2).strength(0.05));

            const link = svg.append("g")
              .attr("stroke", "#aaa")
              .attr("stroke-width", 1)
              .selectAll("line")
              .data(graph.links)
              .enter()
              .append("line");

            const node = svg.append("g")
              .selectAll("g")
              .data(graph.nodes)
              .enter()
              .append("g")
              .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

            node.append("circle")
              .attr("r", 8)
              .attr("fill", d => color(d.type));

            node.append("title")
              .text(d => d.label);

            node.append("text")
              .attr("x", 10)
              .attr("y", 3)
              .attr("fill", "#ffffff")
              .attr("font-size", "10px")
              .text(d => d.label);

            simulation.on("tick", () => {
              link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

              node
                .attr("transform", d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event, d) {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            }

            function dragged(event, d) {
              d.fx = event.x;
              d.fy = event.y;
            }

            function dragended(event, d) {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            }
          }

          // ---------- CHART DATA PREP ----------
          function initChartDataFromSparql(data) {
            const bindings = data.results?.bindings || [];
            const byMol2 = new Map(); // key: molecule2 URI, value: { label, rows }

            bindings.forEach(row => {
              const parentURI = row.molecule2?.value;
              const mol2Name = row.mol2Name?.value || parentURI;
              if (!parentURI) return;

              if (!byMol2.has(parentURI)) {
                byMol2.set(parentURI, { label: mol2Name, rows: [] });
              }
              byMol2.get(parentURI).rows.push(row);
            });

            const selector = document.getElementById("moleculeSelector");
            if (!selector) return;

            // Clear old options
            selector.innerHTML = "";

            // Fill with options
            for (const [uri, info] of byMol2.entries()) {
              const opt = document.createElement("option");
              opt.value = uri;
              opt.textContent = info.label;
              selector.appendChild(opt);
            }

            // If we have at least one molecule, draw chart for the first
            const first = selector.options[0];
            if (first) {
              drawSelectivityChart(data, first.value, currentScaleType);
            } else {
              // No options / no data
              const svg = d3.select("#chart");
              svg.selectAll("*").remove();
            }
          }

          // ---------- DRAW SELECTIVITY BAR CHART ----------
          function drawSelectivityChart(data, molecule2URI, scaleType = "linear") {
            const bindings = data.results?.bindings || [];

            // Filter rows for this parent molecule
            const rows = bindings.filter(row => row.molecule2?.value === molecule2URI);

            const chartData = rows.map(row => {
              const targetName = row.targetName?.value || row.target?.value || "unknown";
              const selRaw = row.Selectivity_vs_best?.value;
              const kiRaw = row.Ki?.value;
              const kiBestRaw = row.KiBest?.value;

              let selectivity = selRaw ? parseFloat(selRaw) : NaN;
              if (!isNaN(selectivity) && selectivity !== 0) {
                selectivity = 1 / selectivity;
              }

              return {
                targetName,
                selectivity: selectivity,
                Ki: kiRaw ? parseFloat(kiRaw) : NaN,
                KiBest: kiBestRaw ? parseFloat(kiBestRaw) : NaN
              };
            }).filter(d => !isNaN(d.selectivity));

            const svg = d3.select("#chart");
            svg.selectAll("*").remove();

            const fullWidth = +svg.attr("width");
            const fullHeight = +svg.attr("height");
            const margin = { top: 30, right: 20, bottom: 100, left: 60 };
            const width = fullWidth - margin.left - margin.right;
            const height = fullHeight - margin.top - margin.bottom;

            const g = svg.append("g")
              .attr("transform", `translate(${margin.left},${margin.top})`);

            if (chartData.length === 0) {
              g.append("text")
                .attr("x", width / 2)
                .attr("y", height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "white")
                .text("No selectivity data for this molecule.");
              return;
            }

            const x = d3.scaleBand()
              .domain(chartData.map(d => d.targetName))
              .range([0, width])
              .padding(0.2);

            let y;
            if (scaleType === "log") {
              // For log scale, we need a positive min value.
              // We'll find the min > 0, or default to something small like 0.1 if everything is 0?
              // Selectivity is usually >= 1 if it's Ki/KiBest, but let's be safe.
              const minVal = d3.min(chartData, d => (d.selectivity > 0 ? d.selectivity : null)) || 0.1;
              const maxVal = d3.max(chartData, d => d.selectivity) || 100;

              y = d3.scaleLog()
                .domain([minVal, maxVal])
                .range([height, 0])
                .nice();
            } else {
              y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d.selectivity) || 1])
                .nice()
                .range([height, 0]);
            }

            // X axis
            const xAxis = d3.axisBottom(x);
            g.append("g")
              .attr("transform", `translate(0,${height})`)
              .call(xAxis)
              .selectAll("text")
              .attr("transform", "rotate(-45)")
              .style("text-anchor", "end")
              .attr("fill", "white");

            // Y axis
            const yAxis = d3.axisLeft(y);
            g.append("g")
              .call(yAxis)
              .selectAll("text")
              .attr("fill", "white");

            g.selectAll(".axis path, .axis line")
              .attr("stroke", "white");

            // Bars
            g.selectAll(".bar")
              .data(chartData)
              .enter()
              .append("rect")
              .attr("class", "bar")
              .attr("x", d => x(d.targetName))
              .attr("y", d => y(d.selectivity))
              .attr("width", x.bandwidth())
              .attr("height", d => height - y(d.selectivity))
              .attr("fill", "#66ccff");

            // Y label
            g.append("text")
              .attr("x", -40)
              .attr("y", -10)
              .attr("fill", "white")
              .text("Selectivity_vs_best");

            // Title-ish
            g.append("text")
              .attr("x", width / 2)
              .attr("y", -10)
              .attr("text-anchor", "middle")
              .attr("fill", "white")
              .text("Target selectivity for chosen parent molecule");
          }
          // When user chooses another parent molecule, redraw chart
          const molSelector = document.getElementById("moleculeSelector");
          if (molSelector) {
            molSelector.addEventListener("change", function () {
              if (lastSparqlData) {
                drawSelectivityChart(lastSparqlData, this.value, currentScaleType);
              }
            });
          }

          // Scale Toggle Buttons
          const btnLinear = document.getElementById("btnLinear");
          const btnLog = document.getElementById("btnLog");

          if (btnLinear && btnLog) {
            btnLinear.addEventListener("click", () => {
              currentScaleType = "linear";
              // Update button styles
              btnLinear.style.backgroundColor = "#66ccff";
              btnLog.style.backgroundColor = "#ddd";

              // Redraw
              const sel = document.getElementById("moleculeSelector");
              if (lastSparqlData && sel && sel.value) {
                drawSelectivityChart(lastSparqlData, sel.value, currentScaleType);
              }
            });

            btnLog.addEventListener("click", () => {
              currentScaleType = "log";
              // Update button styles
              btnLinear.style.backgroundColor = "#ddd";
              btnLog.style.backgroundColor = "#66ccff";

              // Redraw
              const sel = document.getElementById("moleculeSelector");
              if (lastSparqlData && sel && sel.value) {
                drawSelectivityChart(lastSparqlData, sel.value, currentScaleType);
              }
            });
          }



          // ---------- VIEW SELECTOR ----------
          document.getElementById("viewSelector").addEventListener("change", function () {
            const view = this.value;

            const tableDiv = document.getElementById("tableContainer");
            const graphDiv = document.getElementById("graphContainer");
            const chartDiv = document.getElementById("chartContainer");

            if (view === "table") {
              tableDiv.style.display = "block";
              graphDiv.style.display = "none";
              chartDiv.style.display = "none";
            } else if (view === "graph") {
              tableDiv.style.display = "none";
              graphDiv.style.display = "block";
              chartDiv.style.display = "none";
            } else if (view === "chart") {
              tableDiv.style.display = "none";
              graphDiv.style.display = "none";
              chartDiv.style.display = "block";
            }
          });

          // ---------- BUTTON WIRING ----------
          document.getElementById('run').addEventListener('click', runSparql);

          window.addEventListener('load', async () => {
            await runSparql(); // fetches data + draws graph automatically

            const viewSelector = document.getElementById("viewSelector");
            viewSelector.value = "graph";                // correct value
            viewSelector.dispatchEvent(new Event('change'));  // triggers your view switcher
          });
        </script>

</body>
</html>
