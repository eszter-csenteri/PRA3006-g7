<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Radiopharmaceuticals ðŸ§ </title>

  <!-- CSS -->
  <link rel="stylesheet" href="HTML/style.css">

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
  <div class="layout">
    <!-- LEFT SIDEBAR -->
    <nav class="sidebar">
      <ul>
        <li><a href="MAIN.html">Home</a></li>
        <li><a href="HTML/about.html">Author</a></li>
        <li><a href="HTML/Dishes.html">Dishes</a></li>
        <li><a href="HTML/test.html">Test</a></li>
      </ul>
    </nav>

    <div class="content-wrapper">
      <h1>Radiopharmaceuticals</h1>
      <h2 style="text-align:center;">Exploring protein targets visually</h2>

      <h2>What are radiopharmaceuticals?</h2>
      <hr>
      <i> You can find an inspiration for our project
        <a href="https://reasonator.toolforge.org/?q=Q33202843&lang=en" target="_blank" style="color:white;">
          here.
        </a>

      </i>
      <br><br>

      <p>
        <img src="https://pubs.acs.org/cms/10.1021/acscentsci.3c01050/asset/images/large/oc3c01050_0001.jpeg"
          alt="Radiopharmaceuticals diagram" height="200">
        Radiopharmaceuticals, or medicinal radiocompounds, are a group of pharmaceutical drugs containing radioactive
        isotopes...
      </p>

      <h3>Summarised desired properties of radiopharmaceuticals:</h3>
      <ul>
        <li>Low binding inhibition constant (Ki)</li>
        <li>Low dissociation constants (Kd &lt; 10 nM)</li>
        <li>Slow but reversible off-rates</li>
        <li>Small molecular weight (&lt; 450 Da)</li>
        <li>Moderately lipophilic (logP 0.9â€“2.5)</li>
        <li>No P-glycoprotein substrate activity</li>
      </ul>

      <hr>
      <div class="box">
        Research question: Which receptors are most commonly targeted by radiopharmaceuticals, and how do their binding
        selectivity profiles vary?
      </div>

      <h2>How were protein targets determined?</h2>
      <hr>

      <p>When looking for radiopharmaceuticals linked to their relevant receptors, only ...</p>
      <hr style="height:5px; background-color: white;">
      <h2>SPARQL Explorer</h2>
      <h3>Instructions:</h3>
      <ul>
        <li>Enter the SPARQL endpoint URL (default is set to ChEMBL mirror)</li>
        <li>Enter your SPARQL query in the text area (a default query is provided)</li>
        <li>Click the "Run Query" button to execute the query</li>
        <li>View the results in the "Results" section below the button</li>
        <li>The knowledge graph visualization will be displayed in the SVG area below the results</li>
      </ul>
      <script>
        console.log("D3 version:", d3.version);
      </script>

      <div class="section">


        <label for="endpoint">Endpoint URL:</label><br>
        <input id="endpoint" type="text" value="https://chemblmirror.rdf.bigcat-bioinformatics.org/sparql"><br><br>

        <!-- SPARQL QUERY -->
        <label for="query">SPARQL Query:</label><br>
        <textarea id="query" rows="8" style="width:100%;">
PREFIX cco:   <http://rdf.ebi.ac.uk/terms/chembl#>
PREFIX rdfs:  <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd:   <http://www.w3.org/2001/XMLSchema#>

SELECT DISTINCT
  ?molecule           # radiopharmaceutical child
  ?molName
  ?atcCode
  ?molecule2          # parent molecule (the one with binding data)
  ?mol2Name
  ?target
  ?targetName
  ?Ki                 # best Ki (nM) for this target & molecule2
  ?KiBest             # best Ki over all targets for this molecule2
  (xsd:decimal(?Ki) / xsd:decimal(?KiBest) AS ?Selectivity_vs_best)
WHERE {

  ######## Radiopharmaceutical and parent molecule ########

  ?molecule a cco:SmallMolecule ;
            rdfs:label ?molName ;
            cco:atcClassification ?atcCode ;
            cco:hasParentMolecule ?molecule2 .

  FILTER(STRSTARTS(STR(?atcCode), "V09") || STRSTARTS(STR(?atcCode), "V10"))

  ?molecule2 rdfs:label ?mol2Name .

  ######## Per-target Ki for each parent molecule (molecule2) ########

  {
    SELECT ?molecule2 ?target ?targetName (MIN(xsd:decimal(?value)) AS ?Ki)
    WHERE {
      ?activity  cco:hasMolecule ?molecule2 ;
                 cco:hasAssay    ?assay ;
                 cco:type        ?type ;
                 cco:standardValue ?value .

      ?assay cco:hasTarget ?target .
      ?target rdfs:label ?targetName .

      FILTER(?type = "Ki")
    }
    GROUP BY ?molecule2 ?target ?targetName
  }

  ######## Best Ki per molecule2 ########

  {
    SELECT ?molecule2 (MIN(xsd:decimal(?valueBest)) AS ?KiBest)
    WHERE {
      ?activityBest  cco:hasMolecule ?molecule2 ;
                     cco:hasAssay    ?assayBest ;
                     cco:type        ?typeBest ;
                     cco:standardValue ?valueBest .
      FILTER(?typeBest = "Ki")
    }
    GROUP BY ?molecule2
  }
}
ORDER BY ?molecule2 ?Selectivity_vs_best
LIMIT 500
      </textarea><br>

        <button id="run" style="background-color:#04AA6D; color:white; padding:5px 10px; border:none; cursor:pointer;">
          Run Query
        </button>

        <!-- VIEW SELECTOR -->
        <br><br>
        <label style="color:white;">View:</label>
        <select id="viewSelector" style="margin-left:10px; padding:5px;">
          <option value="table">Table (Query Results)</option>
          <option value="graph">Knowledge Graph</option>
          <option value="chart">Selectivity Chart</option>
        </select>

        <!-- TABLE RESULTS -->
        <div id="tableContainer" style="margin-top:20px; color:white;">
          <div id="results"></div>
        </div>

        <!-- GRAPH RESULTS -->
        <div id="graphContainer" style="display:none; margin-top:20px;">
          <h2 style="color:white;">Knowledge graph</h2>
          <svg id="graph" width="1000" height="1000" style="background:#102030;"></svg>
        </div>

        <!-- CHART RESULTS -->
        <div id="chartContainer" style="display:none; margin-top:20px;">
          <h2 style="color:white;">Selectivity vs best Ki</h2>
          <label style="color:white;">Parent molecule:</label>
          <select id="moleculeSelector" style="margin-left:10px; padding:5px;"></select>

          <span style="margin-left: 20px; color: white;">Scale:</span>
          <button id="btnLinear"
            style="margin-left:5px; padding:5px; cursor:pointer; background-color:#66ccff; border:none;">Linear</button>
          <button id="btnLog"
            style="margin-left:5px; padding:5px; cursor:pointer; background-color:#ddd; border:none;">Logarithmic</button>

          <svg id="chart" width="1000" height="400" style="background:#102030; margin-top:10px;"></svg>
        </div>


        <script>
          let lastSparqlData = null;  // will store the latest SPARQL JSON
          let currentScaleType = "linear"; // "linear" or "log"

          // ---------- TABLE RENDERING ----------
          function renderResults(data) {
            const bindings = data.results?.bindings || [];

            if (bindings.length === 0) {
              return '<p>No results.</p>';
            }

            const vars = data.head?.vars || Object.keys(bindings[0] || {});
            let html = '<table style="border-collapse:collapse; color:white; font-size:0.9rem;">';

            // Header
            html += '<thead><tr>';
            vars.forEach(v => {
              html += `<th style="border:1px solid #555; padding:4px;">${escapeHtml(v)}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Rows
            bindings.forEach(row => {
              html += '<tr>';
              vars.forEach(v => {
                const cell = row[v];
                const value = cell ? cell.value : '';
                let cellHtml = escapeHtml(value);

                if (cell && cell.type === 'uri' && value) {
                  const safeUri = escapeHtml(value);
                  cellHtml = `<a href="${safeUri}" target="_blank" style="color:#7fc5ff;">${safeUri}</a>`;
                }

                html += `<td style="border:1px solid #555; padding:4px;">${cellHtml}</td>`;
              });
              html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
          }

          function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text == null ? '' : String(text);
            return div.innerHTML;
          }

          // ---------- SPARQL RUNNER ----------
          async function runSparql() {
            const endpoint = document.getElementById('endpoint').value.trim();
            const query = document.getElementById('query').value.trim();
            const resultsDiv = document.getElementById('results');

            if (!endpoint || !query) {
              resultsDiv.innerHTML = '<p style="color:red;">Endpoint and query required.</p>';
              return;
            }

            resultsDiv.innerHTML = '<p>Loadingâ€¦</p>';

            let url;
            try {
              url = new URL(endpoint);
            } catch (e) {
              resultsDiv.innerHTML = `<p style="color:red;">Invalid endpoint URL.</p>`;
              console.error('Invalid endpoint URL:', endpoint, e);
              return;
            }

            url.searchParams.append('query', query);
            url.searchParams.append('format', 'json');

            try {
              console.log('Sending SPARQL request to:', url.toString());

              const response = await fetch(url.toString(), {
                method: 'GET',
                headers: { 'Accept': 'application/sparql-results+json' }
              });

              console.log('Response status:', response.status);

              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }

              const data = await response.json();
              console.log('SPARQL JSON result:', data);

              // âœ… STORE SPARQL DATA globally for chart & interactions
              lastSparqlData = data;

              // âœ… Render table
              resultsDiv.innerHTML = renderResults(data);

              // âœ… Draw graph
              if (typeof drawGraphFromSparql === 'function') {
                drawGraphFromSparql(data);
              } else {
                console.warn('drawGraphFromSparql is not defined.');
              }

              // âœ… Initialize selectivity chart molecule dropdown
              initChartDataFromSparql(data);

              // âœ… Reset view to TABLE by default
              document.getElementById("viewSelector").value = "table";
              document.getElementById("tableContainer").style.display = "block";
              document.getElementById("graphContainer").style.display = "none";
              document.getElementById("chartContainer").style.display = "none";

            } catch (err) {
              console.error('SPARQL error:', err);
              resultsDiv.innerHTML =
                `<p style="color:red;">Error: ${escapeHtml(err.message)}</p>`;
            }
          }

          // ---------- GRAPH BUILDING ----------
          function buildGraphFromSparql(data) {
            const bindings = data.results?.bindings || [];

            const nodeMap = new Map();
            const links = [];

            function addNode(id, label, type) {
              if (!id) return null;
              if (!nodeMap.has(id)) {
                nodeMap.set(id, { id, label, type });
              }
              return nodeMap.get(id);
            }

            bindings.forEach(row => {
              const moleculeURI = row.molecule?.value;
              const molName = row.molName?.value || moleculeURI;

              const parentURI = row.molecule2?.value;
              const mol2Name = row.mol2Name?.value || parentURI;

              const targetURI = row.target?.value;
              const targetName = row.targetName?.value || targetURI;

              const moleculeNode = addNode(moleculeURI, molName, "molecule");
              const parentNode = addNode(parentURI, mol2Name, "parent");
              const targetNode = addNode(targetURI, targetName, "target");

              if (moleculeNode && parentNode) {
                links.push({
                  source: moleculeNode.id,
                  target: parentNode.id,
                  relation: "hasParentMolecule"
                });
              }

              if (parentNode && targetNode) {
                links.push({
                  source: parentNode.id,
                  target: targetNode.id,
                  relation: "hasTarget"
                });
              }
            });

            return {
              nodes: Array.from(nodeMap.values()),
              links
            };
          }

          // ---------- GRAPH DRAWING ----------
          function drawGraphFromSparql(data) {
            const graph = buildGraphFromSparql(data);

            const svg = d3.select("#graph");
            svg.selectAll("*").remove();

            const width = +svg.attr("width");
            const height = +svg.attr("height");

            const color = d3.scaleOrdinal()
              .domain(["molecule", "parent", "target"])
              .range(["#ffcc00", "#66ccff", "#ff6699"]);

            // Legend
            const legendData = [
              { type: "molecule", label: "Molecule (molName)" },
              { type: "parent", label: "Parent Molecule (mol2Name)" },
              { type: "target", label: "Target (targetName)" }
            ];

            const legend = svg.append("g")
              .attr("class", "legend")
              .attr("transform", "translate(20, 20)");

            legend.selectAll("legend-dots")
              .data(legendData)
              .enter()
              .append("circle")
              .attr("cx", 0)
              .attr("cy", (d, i) => i * 22)
              .attr("r", 7)
              .style("fill", d => color(d.type));

            legend.selectAll("legend-labels")
              .data(legendData)
              .enter()
              .append("text")
              .attr("x", 15)
              .attr("y", (d, i) => i * 22 + 4)
              .style("fill", "white")
              .style("font-size", "14px")
              .text(d => d.label);

            const simulation = d3.forceSimulation(graph.nodes)
              .force("link", d3.forceLink(graph.links)
                .id(d => d.id)
                .distance(80))
              .force("charge", d3.forceManyBody().strength(-120))
              .force("center", d3.forceCenter(width / 2, height / 2))
              .force("x", d3.forceX(width / 2).strength(0.05))
              .force("y", d3.forceY(height / 2).strength(0.05));

            const link = svg.append("g")
              .attr("stroke", "#aaa")
              .attr("stroke-width", 1)
              .selectAll("line")
              .data(graph.links)
              .enter()
              .append("line");

            const node = svg.append("g")
              .selectAll("g")
              .data(graph.nodes)
              .enter()
              .append("g")
              .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

            node.append("circle")
              .attr("r", 8)
              .attr("fill", d => color(d.type));

            node.append("title")
              .text(d => d.label);

            node.append("text")
              .attr("x", 10)
              .attr("y", 3)
              .attr("fill", "#ffffff")
              .attr("font-size", "10px")
              .text(d => d.label);

            simulation.on("tick", () => {
              link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

              node
                .attr("transform", d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event, d) {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            }

            function dragged(event, d) {
              d.fx = event.x;
              d.fy = event.y;
            }

            function dragended(event, d) {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            }
          }

          // ---------- CHART DATA PREP ----------
          function initChartDataFromSparql(data) {
            const bindings = data.results?.bindings || [];
            const byMol2 = new Map(); // key: molecule2 URI, value: { label, rows }

            bindings.forEach(row => {
              const parentURI = row.molecule2?.value;
              const mol2Name = row.mol2Name?.value || parentURI;
              if (!parentURI) return;

              if (!byMol2.has(parentURI)) {
                byMol2.set(parentURI, { label: mol2Name, rows: [] });
              }
              byMol2.get(parentURI).rows.push(row);
            });

            const selector = document.getElementById("moleculeSelector");
            if (!selector) return;

            // Clear old options
            selector.innerHTML = "";

            // Fill with options
            for (const [uri, info] of byMol2.entries()) {
              const opt = document.createElement("option");
              opt.value = uri;
              opt.textContent = info.label;
              selector.appendChild(opt);
            }

            // If we have at least one molecule, draw chart for the first
            const first = selector.options[0];
            if (first) {
              drawSelectivityChart(data, first.value, currentScaleType);
            } else {
              // No options / no data
              const svg = d3.select("#chart");
              svg.selectAll("*").remove();
            }
          }

          // ---------- DRAW SELECTIVITY BAR CHART ----------
          function drawSelectivityChart(data, molecule2URI, scaleType = "linear") {
            const bindings = data.results?.bindings || [];

            // Filter rows for this parent molecule
            const rows = bindings.filter(row => row.molecule2?.value === molecule2URI);

            const chartData = rows.map(row => {
              const targetName = row.targetName?.value || row.target?.value || "unknown";
              const selRaw = row.Selectivity_vs_best?.value;
              const kiRaw = row.Ki?.value;
              const kiBestRaw = row.KiBest?.value;

              let selectivity = selRaw ? parseFloat(selRaw) : NaN;
              if (!isNaN(selectivity) && selectivity !== 0) {
                selectivity = 1 / selectivity;
              }

              return {
                targetName,
                selectivity: selectivity,
                Ki: kiRaw ? parseFloat(kiRaw) : NaN,
                KiBest: kiBestRaw ? parseFloat(kiBestRaw) : NaN
              };
            }).filter(d => !isNaN(d.selectivity));

            const svg = d3.select("#chart");
            svg.selectAll("*").remove();

            const fullWidth = +svg.attr("width");
            const fullHeight = +svg.attr("height");
            const margin = { top: 30, right: 20, bottom: 100, left: 60 };
            const width = fullWidth - margin.left - margin.right;
            const height = fullHeight - margin.top - margin.bottom;

            const g = svg.append("g")
              .attr("transform", `translate(${margin.left},${margin.top})`);

            if (chartData.length === 0) {
              g.append("text")
                .attr("x", width / 2)
                .attr("y", height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "white")
                .text("No selectivity data for this molecule.");
              return;
            }

            const x = d3.scaleBand()
              .domain(chartData.map(d => d.targetName))
              .range([0, width])
              .padding(0.2);

            let y;
            if (scaleType === "log") {
              // For log scale, we need a positive min value.
              // We'll find the min > 0, or default to something small like 0.1 if everything is 0?
              // Selectivity is usually >= 1 if it's Ki/KiBest, but let's be safe.
              const minVal = d3.min(chartData, d => (d.selectivity > 0 ? d.selectivity : null)) || 0.1;
              const maxVal = d3.max(chartData, d => d.selectivity) || 100;

              y = d3.scaleLog()
                .domain([minVal, maxVal])
                .range([height, 0])
                .nice();
            } else {
              y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d.selectivity) || 1])
                .nice()
                .range([height, 0]);
            }

            // X axis
            const xAxis = d3.axisBottom(x);
            g.append("g")
              .attr("transform", `translate(0,${height})`)
              .call(xAxis)
              .selectAll("text")
              .attr("transform", "rotate(-45)")
              .style("text-anchor", "end")
              .attr("fill", "white");

            // Y axis
            const yAxis = d3.axisLeft(y);
            g.append("g")
              .call(yAxis)
              .selectAll("text")
              .attr("fill", "white");

            g.selectAll(".axis path, .axis line")
              .attr("stroke", "white");

            // Bars
            g.selectAll(".bar")
              .data(chartData)
              .enter()
              .append("rect")
              .attr("class", "bar")
              .attr("x", d => x(d.targetName))
              .attr("y", d => y(d.selectivity))
              .attr("width", x.bandwidth())
              .attr("height", d => height - y(d.selectivity))
              .attr("fill", "#66ccff");

            // Y label
            g.append("text")
              .attr("x", -40)
              .attr("y", -10)
              .attr("fill", "white")
              .text("Selectivity_vs_best");

            // Title-ish
            g.append("text")
              .attr("x", width / 2)
              .attr("y", -10)
              .attr("text-anchor", "middle")
              .attr("fill", "white")
              .text("Target selectivity for chosen parent molecule");
          }
          // When user chooses another parent molecule, redraw chart
          const molSelector = document.getElementById("moleculeSelector");
          if (molSelector) {
            molSelector.addEventListener("change", function () {
              if (lastSparqlData) {
                drawSelectivityChart(lastSparqlData, this.value, currentScaleType);
              }
            });
          }

          // Scale Toggle Buttons
          const btnLinear = document.getElementById("btnLinear");
          const btnLog = document.getElementById("btnLog");

          if (btnLinear && btnLog) {
            btnLinear.addEventListener("click", () => {
              currentScaleType = "linear";
              // Update button styles
              btnLinear.style.backgroundColor = "#66ccff";
              btnLog.style.backgroundColor = "#ddd";

              // Redraw
              const sel = document.getElementById("moleculeSelector");
              if (lastSparqlData && sel && sel.value) {
                drawSelectivityChart(lastSparqlData, sel.value, currentScaleType);
              }
            });

            btnLog.addEventListener("click", () => {
              currentScaleType = "log";
              // Update button styles
              btnLinear.style.backgroundColor = "#ddd";
              btnLog.style.backgroundColor = "#66ccff";

              // Redraw
              const sel = document.getElementById("moleculeSelector");
              if (lastSparqlData && sel && sel.value) {
                drawSelectivityChart(lastSparqlData, sel.value, currentScaleType);
              }
            });
          }



          // ---------- VIEW SELECTOR ----------
          document.getElementById("viewSelector").addEventListener("change", function () {
            const view = this.value;

            const tableDiv = document.getElementById("tableContainer");
            const graphDiv = document.getElementById("graphContainer");
            const chartDiv = document.getElementById("chartContainer");

            if (view === "table") {
              tableDiv.style.display = "block";
              graphDiv.style.display = "none";
              chartDiv.style.display = "none";
            } else if (view === "graph") {
              tableDiv.style.display = "none";
              graphDiv.style.display = "block";
              chartDiv.style.display = "none";
            } else if (view === "chart") {
              tableDiv.style.display = "none";
              graphDiv.style.display = "none";
              chartDiv.style.display = "block";
            }
          });

          // ---------- BUTTON WIRING ----------
          document.getElementById('run').addEventListener('click', runSparql);
        </script>

</body>
</html>
